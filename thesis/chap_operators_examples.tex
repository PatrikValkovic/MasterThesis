\chapter{Selected operators implementation}
\label{chap:impl}

\begin{algorithm}
\begin{lstlisting}[language=Python, xrightmargin=18pt, breaklines=true, postbreak=\mbox{$\hookrightarrow$\space}, literate={\ \ }{{\ }}1]
from typing import Tuple, Any, Dict, Union, Callable
import torch as t
from ffeat import Pipe
from ffeat.utils._parental_sampling import randint

_IFU = Union[int, float]

class Tournament(Pipe):
    def __init__(self, num_select=None, maximization=False, parents=2, parental_sampling=randint):
        self._num_select = self._handle_parameter(num_select)
        self._maximization=maximization
        self._parents = parents
        self._parental_sampling = parental_sampling

    def __call__(self, fitnesses, population, *args, **kwargs):
        originally = len(population)
        to_select = self._num_select(fitnesses, population, *args, **kwargs)

        indices = self._parental_sampling(originally, to_select, self._parents, fitnesses.device)
        operation = t.argmax if self._maximization else t.argmin
        best_indices = operation(fitnesses[indices], dim=1)
        selected = population[indices[range(to_select),best_indices]]

        return (selected, *args), kwargs
\end{lstlisting}
\caption{Tournament selection implementation}
\label{alg:impltournament}
\end{algorithm}

\begin{algorithm}
\begin{lstlisting}[language=Python, xrightmargin=18pt, breaklines=true, postbreak=\mbox{$\hookrightarrow$\space}, literate={\ \ }{{\ }}1]
from typing import Tuple, Any, Dict, Union
import torch as t
from ffeat import Pipe
from ._Shared import _CommonCrossover
from ffeat.utils._parental_sampling import randint

class OnePoint1D(Pipe, _CommonCrossover):
    def __init__(self, offsprings, replace_parents=True, in_place=True, discard_parents=False, parental_sampling=randint):
        _Shared.__init__(self, offsprings, replace_parents, in_place, discard_parents)
        self._parental_sampling = parental_sampling

    def __call__(self, population, *args, **kwargs):
        ptp = population.dtype if population.dtype != t.bool else t.uint8
        dev = population.device
        dim = population.shape[1]
        num_crossovers = self._offsprings // 2
        crossover_indices = t.randint(1, dim, size=(num_crossovers,), dtype=t.long, device=dev)
        parents_indices = self._parental_sampling(len(population), num_crossovers, 2, dev).T
        children = t.zeros((num_crossovers, dim), dtype=ptp, device=dev)
        position_mask = t.arange(dim, device=dev).as_strided((num_crossovers,dim), (0,1))
        lpos = (position_mask < crossover_indices[:, None]).type(t.int8)
        children[:num_crossovers].add_(population[parents_indices[0]] * lpos)
        children[num_crossovers:].add_(population[parents_indices[1]] * lpos)
        rpos = t.logical_not(lpos, out=lpos)
        children[:num_crossovers].add_(population[parents_indices[1]] * rpos)
        children[num_crossovers:].add_(population[parents_indices[0]] * lpos)
        children = children.to(population.dtype)
        pop = self._handle_pop(population, children, parents_indices)
        return (pop, *args), kwargs
\end{lstlisting}
\caption{One--point crossover operator}
\label{alg:implonepoint}
\end{algorithm}

\begin{algorithm}
\begin{lstlisting}[language=Python, xrightmargin=18pt, breaklines=true, postbreak=\mbox{$\hookrightarrow$\space}, literate={\ \ }{{\ }}1]
from typing import Tuple, Any, Dict, Union, Callable
import torch as t
from ffeat import Pipe, flow

class Elitism(Pipe):
    def __init__(self,
                 num_elites,
                 *following_steps,
                 maximization=False):
        self._num_elites = self._handle_parameter(num_elites)
        self._maximization = maximization
        self.__follow = flow.Sequence(*following_steps)

    def __call__(self, fitnesses, population, *args, **kwargs):
        to_select = self._num_elites(fitnesses, population, *args, **kwargs)
        elites_indices = t.topk(fitnesses, to_select, largest=self._maximization)[1]
        elites = t.clone(population[elites_indices])
        (population, *args), kargs = self.__follow(fitnesses, population, *args, **kwargs)
        population[elites_indices] = elites
        return (population, *args), kwargs
\end{lstlisting}
\caption{Elitism operator implementation}
\label{alg:implelitism}
\end{algorithm}